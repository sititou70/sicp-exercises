3 者の考えにはいずれも利点と欠点があり、どれかを決定的に支持することはできない。

Ben の考えは、宣言が逐次ルールにしたがうべきというものである。これは、逐次的、命令的なプログラマの考えによくマッチするという利点がある。一方で、定義の動作を理解するためには時間という概念が不可欠になり、予期しないバグが発生するかもしれないという欠点もある。誤って定義前の変数を参照してしまった場合、同じ名前の外側の環境の変数を参照してしまうかもしれない。

Eva の考えは、定義は真に同時に行われるべきというものである。これは、宣言的、関数的なプログラマの考えにマッチするという利点がある。定義は宣言的に処理されるため、挙動を把握しやすくなる。しかし、本文の脚注でも述べられているとおり、これを効率的に実装することは難しい。

Alyssa の考えは、同じスコープで定義前の変数を参照しようとするとエラーを発生させるというものである。これは、両者の考えの折衷案になっているように見える。エラーが発生する場合があるという欠点はある。しかし、命令的な書き方による意図しない挙動を制限しつつ、実装もしやすいという利点もある。

Eva の案を実装するアイデアは、値の参照を「遅延させる」仕組みを用意することである。本文中の「even?」手続きの宣言は、内部で定義前の「odd?」に依存しているにも関わらず問題なく処理されている。これは、「even?」が手続きであって、「odd?」の参照は「even?」が適用されたときに起こるからである。つまり、本当に必要になったときまで参照が「遅延」されているのである。同じように、値についても定義時に評価するのではなく、それが必要となるときまで遅延させるようにできる。

実装方針は以下のようになる

1. 手続きが実行されるとき、まずすべての定義について走査し、それらの値を「遅延」オブジェクトで包む
1. 定義以外の式によって定義が参照されるとき、それが遅延オブジェクトであれは force してその値が参照される。そうでない（＝過去に既に force されている）場合、その値が参照される。

問題文中の例では、まず b と a は、それぞれ「(delay (+ a x))」、「(delay 5)」というオブジェクトとして宣言される。式「(+ a b)」が評価されるとき、まず a が参照される（という言語実装であると仮定する）。a はまだ遅延オブジェクトなので「(delay 5)」が force されて、a は 5 であるとわかる。次に b が参照される。 ここで b もまた遅延オブジェクトなので、「(delay (+ a x))」が force される。ここで a が参照されるが、これは既に遅延オブジェクトではないので 5 と評価され、b は 15 となる。最後に結果として 20 を得る。

参考：http://community.schemewiki.org/?sicp-ex-4.19
