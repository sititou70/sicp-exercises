ここでは、任意の型に対する任意の演算が存在することを考える。つまり、型と演算のテーブルに空のセルがないということである。

新しい型が追加されるということは、例えば新しい「hoge 型」を追加する場合、「hoge 型の実部を求める演算」「hoge 型の虚部を求める演算」「hoge 型の絶対値を求める演算」「hoge 型の偏角を求める演算」を追加実装するということである。

新しい演算が追加されるということは、例えば新しい「fuga を求める演算」を追加する場合、「直交座標型の fuga を求める演算」「極座標形式の fuga を求める演算」を追加実装するということである。

## 明示的なディスパッチによるジェネリック演算スタイル

演算の種類によって演算をまとめるスタイルである。言い換えれば、各演算が、すべての型の知識を持っているため、「賢い演算」のスタイルである。

型タグなどによる内部表現によって、「rectangular?」や「polar?」のような述語を用意する。「real-part」や「imag-part」といった演算は、どのようなデータに対してもジェネリックに振る舞うために、先程の述語によって適切な処理を呼び分け（ディスパッチ）する。

### 新しい型が追加されるとき

すべての既存のジェネリック演算に、新しい型を処理するためのコード（条件分岐の節）を追加する。変更箇所が広く分布することになる。

### 新しい演算が追加されるとき

その新しいジェネリック演算を実装する。既存コードへの変更はない。

## データ主導スタイル

get と put 手続きによって「パッケージ」という概念を導入する。「パッケージ」は各演算を、型（データの種類）や演算の種類によってまとめたものである。システムに組み込みの get と put 手続きがあると仮定する。get はパッケージから手続きを公開する。put はパッケージ外から手続きを参照する。

本文では型に着目して演算をまとめる方法を示している。例えば、極座標パッケージは、極座標を扱う演算（極座標の実部を求める演算、極座標の虚部を求める演算、極座標の絶対値を求める演算、極座標の偏角を求める演算）を内部表現として持っており、外部に公開したい演算を put する。

一方で、（本文では言及されていないが）演算の種類ごとに演算をまとめることも可能なはずである。例えば、実部を求める演算パッケージは、実部を求める演算（直交座標形式の実部を求める演算、極座標形式の実部を求める演算）を内部表現として持っており、外部に公開したい演算を put する。

パッケージ外にある演算では、対応する型の演算を get し、それを実行する。例えばあらゆる表現の実部を求める演算に極座標形式が渡される場合を考える。演算は、まず、型タグなどの内部表現によって、渡されたデータの型を得る。ここでは、極座標形式であることが得られる。次に「極座標形式の real-part 演算」を get してそれにデータを渡して実行する。データの種類（型、型タグ）によって必要な演算が選ばれる（ディスパッチされる）ため、データが処理を主導していると考えられる。

注意したいのは、データ主導スタイルは、パッケージや型タグによるディスパッチという概念を導入するが、パッケージが何に着目して構成されるか（型なのか、演算の種類なのか）については言及していないように見えるという点である。

### 新しい型が追加されるとき

本文中のように、型に着目してパッケージを作成している場合は、パッケージを追加するだけで良い。既存コードの変更は必要ない。

一方、演算の種類に着目してパッケージを作成している場合は、すべてのパッケージに追加の演算を定義する必要がある。

### 新しい演算が追加されるとき

本文中のように、型に着目してパッケージを作成している場合は、すべてのパッケージに追加の演算を定義する必要がある。

一方、演算の種類に着目してパッケージを作成している場合は、追加のパッケージを実装するだけで良い。

## メッセージパッシングスタイル

型（データの種類）によって演算をまとめるスタイルである。言い換えれば、各型がすべての演算の知識を持っている、「賢いデータオブジェクト」のスタイルである。

例えば、極座標形式のコンストラクタを実行すると、それに対応する演算へのディスパッチャー手続きが得られる。例えばこれに「real-part」というメッセージを与えると実部を取得できるし、「angle」というメッセージを与えると偏角が得られる。これは OOP スタイルで`z.realPart`とか`z.angle`などと書くのに似ている。

### 新しい型が追加されるとき

新しいデータオブジェクトを追加実装するだけで良い。既存のコードには変更がない。

### 新しい演算が追加されるとき

すべてのデータオブジェクトに追加の演算を定義する必要がある。

## まとめ

### 新しい型が頻繁に追加されるとき

型によって演算をまとめるスタイルが有効である。例えばメッセージパッシングスタイルや、型に着目した場合のデータ主導スタイルである。

### 新しい演算が頻繁に追加されるとき

演算の種類によって演算をまとめるスタイルが有効である。例えば、明示的なディスパッチによるジェネリック演算スタイルや、演算の種類に着目した場合のデータ主導スタイルである。
